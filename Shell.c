#include <stdio.h>#include <stdlib.h>#include <string.h>#include <unistd.h>#include <fcntl.h>#include <signal.h>#include <sys/stat.h>#include <sys/types.h>#define MAX_BUF 1024#define MAX_PATH 128#define READ_FD 0#define WRITE_FD 1struct NODE {	// 백그라운드일 경우 저장할 연결리스트 myjobs로 확인 가능	struct NODE* next;	int pid;	char name[MAX_BUF];};struct NODE* head;int fg;void childsignal() {	int pid, status, isBg = 0;	struct NODE* curr = head;	struct NODE* tmp;	pid = waitpid(-1, &status, 0);	while (curr->next != NULL) {	// 백그라운드 프로세스일 경우 연결리스트에서 제거		if (curr->next->pid == pid) {			tmp = curr->next;			curr->next = curr->next->next;			free(tmp);			isBg = 1;			break;		}		curr = curr->next;	}	if (isBg == 0)		// 포그라운드일 경우 바로 위의 while문에서 if문에 걸리지 않아 isBg가 0이다		fg = 0;}void exec_cmd(char* cmd) {	// cat a.txt 또는 ls -a -l 같은 경우에도 올바르게 실행시켜 줌	char* cmds[50];	int i;	for (i = 0; i < strlen(cmd); i++) {	// 백그라운드 실행을 위한 &를 제거하고 exec를 시키기 위함		if (cmd[i] == '&') {			cmd[i] = '\0';			break;		}	}	if (strchr(cmd, ' ') != NULL) {		int i = 0;		cmds[0] = strtok(cmd, " ");		while (cmds[i] != NULL) {			cmds[i + 1] = strtok(NULL, " ");			i++;		}		execvp(cmd, cmds);	}	else {		execlp(cmd, cmd, NULL);	}}int main() {	char str[MAX_BUF];	char pathname[MAX_PATH];	char* cmd1, * cmd2, * cmd3, * cmd4;	int status;	int amper;	head = malloc(sizeof(struct NODE));	signal(SIGCHLD, childsignal);	pid_t childPid;	while (1) {		memset(str, 0, sizeof(str));		memset(pathname, 0, sizeof(pathname));		getcwd(pathname, MAX_PATH);	// 경로 출력		printf("[JIWAN's Shell] %s $ ", pathname);		fgets(str, sizeof(str), stdin);		str[strlen(str) - 1] = '\0';		// exit 또는 logout 입력시 종료		if (strcmp(str, "exit") == 0 || strcmp(str, "logout") == 0) {			return -1;		}		else if (strncmp(str, "myjobs", 6) == 0) {	// 저장해 놓았던 백그라운드들의 정보들을 모두 출력			printf("myjobs : \n");				struct NODE* curr = head->next;			while (curr != NULL) {				printf("%d	%s\n", curr->pid, curr->name);				curr = curr->next;			}			printf("----end-----\n");		}		else {			if (strchr(str, '&') != NULL) {	// 백그라운드일 경우				amper = 1;			}			else {				amper = 0;			}			childPid = fork();			if (childPid < 0) {	//fork 실패				printf("\nfork error\n");				return -1;			}			if (childPid == 0) {	//child				if (strchr(str, '>') != NULL) {	// 리다이렉션 출력					int fd;					cmd1 = strtok(str, ">");					cmd2 = strtok(NULL, ">");					fd = creat(cmd2, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);					if (fd < 0) {						printf("\nfile create error\n");						return -1;					}					dup2(fd, STDOUT_FILENO);					close(fd);				}				else if (strchr(str, '<') != NULL) {	// 리다이렉션 입력					int fd;					cmd1 = strtok(str, "<");					cmd2 = strtok(NULL, "<");					fd = open(cmd2, O_RDONLY);					if (fd < 0) {						printf("\nfile open error\n");						return -1;					}					dup2(fd, STDIN_FILENO);					close(fd);				}				if (strchr(str, '|') != NULL) { // 파이프 사용하는 경우					int fds[2];					cmd3 = strtok(str, "|");					cmd4 = strtok(NULL, "|");					pipe(fds);					if (fork() == 0) {	// child's child						close(fds[READ_FD]);						dup2(fds[WRITE_FD], 1); // 쓰기용 파이프를 표준출력에 복제						close(fds[WRITE_FD]);						if (amper == 0)							fg = 1;						exec_cmd(cmd3);						perror("pipe");					}					else {		// child						close(fds[WRITE_FD]);						dup2(fds[READ_FD], 0); // 읽기용 파이프를 표준입력에 복제						close(fds[READ_FD]);						if (amper == 0)							fg = 1;						exec_cmd(cmd4);						perror("pipe");					}				}				else {					if (amper == 0)						fg = 1;					exec_cmd(str);				}			}			else {	//parent				if (amper == 0) {	// 포그라운드일 경우 포그라운드 작업이 끝날때 까지 대기					pause();					while (fg == 1)						pause();				}				else {			// 백그라운드일 경우 연결리스트에 추가					struct NODE* curr = head;					while (curr->next != NULL) {						curr = curr->next;					}					curr->next = malloc(sizeof(struct NODE));					curr->next->pid = childPid;					strcpy(curr->next->name, str);				}			}		}	}	return 0;}